from pathlib import Path

def generate_ast_file(base_name: str,
                       data: list[str], 
                       additional_imports: list[str] = []):
    """
    Creates a file plox_lib/asts/<base_name>.py with AST definitions described by <data>.
    The following format is expected:
        ["<class_name> - <field_name: type, >",]
    The <additional_imports> field is to make sure the trees can refer to each other, without
    running into circular imports.

    See the "if __name__ is "__main__":" block below for examples.
    """
    
    lines = [
        "# THIS FILE WAS GENERATED BY 'tool/ast.py' DO NOT MODIFY",
        "",
        "from pydantic.dataclasses import dataclass",
        "from typing import Any, TypeVar, Generic",
        "from abc import abstractmethod, ABC",
        "",
        "from ..token import Token",
    ] + additional_imports + [""]

    lines += _define_visitor(base_name, data)

    lines += [
        "# Required to be frozen and eq since they are used as keys in dicts and need to be hashable",
        "@dataclass(eq=True, frozen=True)",
        f"class {base_name}:",
        "\t@abstractmethod",
        "\tdef accept(self, visitor: Visitor) -> Any: ...",
        "",
    ]

    for ast_data in data:
        name, spec_string = map(lambda s: s.strip(), ast_data.split("-"))
        lines += _generate_ast_class(base_name, name, spec_string)

    (Path(__file__).resolve().parent.parent / f"plox_lib/asts/{base_name.lower()}.py").write_text("\n".join(lines))


def _generate_ast_class(base_class: str, class_name: str, description: str) -> list[str]:
    lines = [
        "@dataclass(eq=True, frozen=True)",
        f"class {class_name}({base_class}):",
    ]

    spec_list = description.split(",")
    for item in spec_list:
        field, rest = map(str.strip, item.split(":", 1))
        lines.append(f"\t{field}: {rest}")
    
    lines += [
        "",
        "\tdef accept(self, visitor: Visitor) -> Any:",
        f"\t\treturn visitor.visit{class_name}{base_class}(self)",
    ]

    return lines + [""]

def _define_visitor(base_name: str, description) -> list[str]:
    lines = ["T = TypeVar(\"T\")", "", "class Visitor(ABC, Generic[T]):"]

    for item in description:
        type_name, _ = map(str.strip, item.split("-", 1))
        lines.append("\t@abstractmethod")
        lines.append(f"\tdef visit{type_name}{base_name}(self, {base_name.lower()}: \"{type_name}\") -> T: ...")
    lines.append("")
    return lines

if __name__ == "__main__":
    
    generate_ast_file("Expr", [
        "Assign   - name: Token, value: Expr",
        "Binary   - left: Expr, operator: Token, right: Expr",
        "Call     - callee: Expr, paren: Token, arguments: list[Expr]", 
        "Get      - object: Expr, name: Token",
        "Grouping - expression: Expr",
        "Literal  - value: object",
        "Logical  - left: Expr, operator: Token, right: Expr",
        "Set      - object: Expr, name: Token, value: Expr",
        "This     - keyword: Token",
        "Unary    - operator: Token, right: Expr",
        "Variable - name: Token",
    ])

    generate_ast_file("Stmt", [
        "Block      - statements: list[Stmt]",
        "Class      - name: Token, methods: list[\"Function\"]",
        "Expression - expression: Expr",
        "Function   - name: Token, params: list[Token], body: list[Stmt]",
        "If         - condition: Expr, thenBranch: Stmt, elseBranch: Stmt | None",
        "Print      - expression: Expr",
        "Return     - keyword: Token, value: Expr | None",
        "Var        - name: Token, initializer: Expr | None",
        "While      - condition: Expr, body: Stmt",
    ],
    ["from .expr import Expr"])